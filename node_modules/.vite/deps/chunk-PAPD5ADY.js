import {
  PopoverContainer,
  Transition,
  arrow_default,
  body_default,
  styles_css_default2 as styles_css_default
} from "./chunk-SEHBNKMU.js";
import {
  internal_default
} from "./chunk-764U3PF5.js";
import {
  Portal,
  clsx_m_default,
  getIsRtl,
  getLogicalBoundingClientRect,
  getScrollInlineStart,
  nodeContains
} from "./chunk-WYPZEXZR.js";
import {
  require_react
} from "./chunk-4HAMFFQC.js";
import {
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/@cloudscape-design/components/internal/components/drag-handle-wrapper/index.js
var import_react4 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/tooltip/index.js
var import_react = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/tooltip/styles.css.js
import "/Users/hbaisani/Hub Explorations/node_modules/@cloudscape-design/components/internal/components/tooltip/styles.scoped.css";
var styles_css_default2 = {
  "root": "awsui_root_1qprf_160mh_5"
};

// node_modules/@cloudscape-design/components/internal/components/tooltip/index.js
function Tooltip({ value, trackRef, trackKey, className, contentAttributes = {}, position = "top", size = "small", hideOnOverscroll, onDismiss }) {
  if (!trackKey && (typeof value === "string" || typeof value === "number")) {
    trackKey = value;
  }
  (0, import_react.useEffect)(() => {
    const controller = new AbortController();
    window.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        event.stopPropagation();
        onDismiss === null || onDismiss === void 0 ? void 0 : onDismiss();
      }
    }, {
      // The tooltip is often activated on mouseover, which means the focus can
      // be anywhere else on the page. Capture also means that this gets called
      // before any wrapper modals or dialogs can detect it and act on it.
      capture: true,
      signal: controller.signal
    });
    return () => {
      controller.abort();
    };
  }, [onDismiss]);
  return import_react.default.createElement(
    Portal,
    null,
    import_react.default.createElement(
      "div",
      { className: `${styles_css_default2.root} ${styles_css_default.root}`, ...contentAttributes, "data-testid": trackKey },
      import_react.default.createElement(Transition, { in: true }, () => import_react.default.createElement(
        PopoverContainer,
        { trackRef, trackKey, size, fixedWidth: false, position, zIndex: 7e3, arrow: (position2) => import_react.default.createElement(arrow_default, { position: position2 }), hideOnOverscroll, className },
        import_react.default.createElement(body_default, { dismissButton: false, dismissAriaLabel: void 0, onDismiss: void 0, header: void 0 }, value)
      ))
    )
  );
}

// node_modules/@cloudscape-design/components/internal/components/drag-handle-wrapper/direction-button.js
var import_react2 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/drag-handle-wrapper/styles.css.js
import "/Users/hbaisani/Hub Explorations/node_modules/@cloudscape-design/components/internal/components/drag-handle-wrapper/styles.scoped.css";
var styles_css_default3 = {
  "direction-button-wrapper": "awsui_direction-button-wrapper_155yk_f1agp_169",
  "direction-button-wrapper-motion-enter": "awsui_direction-button-wrapper-motion-enter_155yk_f1agp_189",
  "direction-button-wrapper-motion-entering": "awsui_direction-button-wrapper-motion-entering_155yk_f1agp_189",
  "direction-button-wrapper-motion-exit": "awsui_direction-button-wrapper-motion-exit_155yk_f1agp_189",
  "direction-button-wrapper-motion-exiting": "awsui_direction-button-wrapper-motion-exiting_155yk_f1agp_189",
  "drag-handle-entry": "awsui_drag-handle-entry_155yk_f1agp_1",
  "awsui-motion-fade-in": "awsui_awsui-motion-fade-in_155yk_f1agp_1",
  "drag-handle-exit": "awsui_drag-handle-exit_155yk_f1agp_1",
  "awsui-motion-fade-out-0": "awsui_awsui-motion-fade-out-0_155yk_f1agp_1",
  "direction-button-wrapper-block-start": "awsui_direction-button-wrapper-block-start_155yk_f1agp_229",
  "direction-button-wrapper-block-end": "awsui_direction-button-wrapper-block-end_155yk_f1agp_233",
  "direction-button-wrapper-inline-start": "awsui_direction-button-wrapper-inline-start_155yk_f1agp_237",
  "direction-button-wrapper-inline-end": "awsui_direction-button-wrapper-inline-end_155yk_f1agp_248",
  "contents": "awsui_contents_155yk_f1agp_259",
  "portal-overlay": "awsui_portal-overlay_155yk_f1agp_263",
  "portal-overlay-disabled": "awsui_portal-overlay-disabled_155yk_f1agp_271",
  "portal-overlay-contents": "awsui_portal-overlay-contents_155yk_f1agp_275",
  "drag-handle": "awsui_drag-handle_155yk_f1agp_279",
  "direction-button-wrapper-hidden": "awsui_direction-button-wrapper-hidden_155yk_f1agp_292",
  "direction-button-wrapper-forced": "awsui_direction-button-wrapper-forced_155yk_f1agp_316",
  "direction-button-wrapper-forced-top-0": "awsui_direction-button-wrapper-forced-top-0_155yk_f1agp_320",
  "direction-button-wrapper-forced-top-1": "awsui_direction-button-wrapper-forced-top-1_155yk_f1agp_324",
  "direction-button-wrapper-forced-top-2": "awsui_direction-button-wrapper-forced-top-2_155yk_f1agp_328",
  "direction-button-wrapper-forced-top-3": "awsui_direction-button-wrapper-forced-top-3_155yk_f1agp_332",
  "direction-button-wrapper-forced-bottom-0": "awsui_direction-button-wrapper-forced-bottom-0_155yk_f1agp_336",
  "direction-button-wrapper-forced-bottom-1": "awsui_direction-button-wrapper-forced-bottom-1_155yk_f1agp_340",
  "direction-button-wrapper-forced-bottom-2": "awsui_direction-button-wrapper-forced-bottom-2_155yk_f1agp_344",
  "direction-button-wrapper-forced-bottom-3": "awsui_direction-button-wrapper-forced-bottom-3_155yk_f1agp_348",
  "direction-button": "awsui_direction-button_155yk_f1agp_169",
  "direction-button-disabled": "awsui_direction-button-disabled_155yk_f1agp_371"
};

// node_modules/@cloudscape-design/components/internal/components/drag-handle-wrapper/test-classes/styles.css.js
import "/Users/hbaisani/Hub Explorations/node_modules/@cloudscape-design/components/internal/components/drag-handle-wrapper/test-classes/styles.scoped.css";
var styles_css_default4 = {
  "root": "awsui_root_8k1rt_1i1h9_5",
  "direction-button": "awsui_direction-button_8k1rt_1i1h9_9",
  "direction-button-visible": "awsui_direction-button-visible_8k1rt_1i1h9_13",
  "direction-button-block-start": "awsui_direction-button-block-start_8k1rt_1i1h9_17",
  "direction-button-block-end": "awsui_direction-button-block-end_8k1rt_1i1h9_21",
  "direction-button-inline-start": "awsui_direction-button-inline-start_8k1rt_1i1h9_25",
  "direction-button-inline-end": "awsui_direction-button-inline-end_8k1rt_1i1h9_29"
};

// node_modules/@cloudscape-design/components/internal/components/drag-handle-wrapper/direction-button.js
var ICON_LOGICAL_PROPERTY_MAP = {
  "block-start": "arrow-up",
  "block-end": "arrow-down",
  "inline-start": "arrow-left",
  "inline-end": "arrow-right"
};
function DirectionButton({ direction, state, show, onClick, forcedPosition, forcedIndex }) {
  return import_react2.default.createElement(Transition, { in: show }, (transitionState, ref) => (
    // The wrapper exists to provide a padding around each direction button that
    // prevents any accidental presses around the button from propagating to any
    // interactive elements behind the button.
    import_react2.default.createElement(
      "span",
      { ref, className: clsx_m_default(styles_css_default3["direction-button-wrapper"], !forcedPosition && styles_css_default3[`direction-button-wrapper-${direction}`], forcedPosition && styles_css_default3["direction-button-wrapper-forced"], forcedPosition && styles_css_default3[`direction-button-wrapper-forced-${forcedPosition}-${forcedIndex}`], transitionState === "exited" && styles_css_default3["direction-button-wrapper-hidden"], styles_css_default3[`direction-button-wrapper-motion-${transitionState}`]) },
      import_react2.default.createElement(
        "span",
        {
          className: clsx_m_default(styles_css_default3["direction-button"], state === "disabled" && styles_css_default3["direction-button-disabled"], styles_css_default4[`direction-button-${direction}`], !["exiting", "exited"].includes(transitionState) && styles_css_default4["direction-button-visible"]),
          onClick: state !== "disabled" ? onClick : void 0,
          // This prevents focus from being lost to `document.body` on
          // mouse/pointer press. This allows us to listen to onClick while
          // keeping this button pointer-accessible only.
          onPointerDown: (event) => event.preventDefault()
        },
        import_react2.default.createElement(internal_default, { name: ICON_LOGICAL_PROPERTY_MAP[direction], size: "small" })
      )
    )
  ));
}

// node_modules/@cloudscape-design/components/internal/components/drag-handle-wrapper/portal-overlay.js
var import_react3 = __toESM(require_react());
function PortalOverlay({ track, isDisabled, children }) {
  const ref = (0, import_react3.useRef)(null);
  const [container, setContainer] = (0, import_react3.useState)(null);
  (0, import_react3.useLayoutEffect)(() => {
    if (track.current) {
      const newContainer = track.current.ownerDocument.createElement("div");
      track.current.ownerDocument.body.appendChild(newContainer);
      setContainer(newContainer);
      return () => newContainer.remove();
    }
  }, [track]);
  (0, import_react3.useEffect)(() => {
    if (track.current === null || isDisabled) {
      return;
    }
    let cleanedUp = false;
    let lastX;
    let lastY;
    let lastInlineSize;
    let lastBlockSize;
    const updateElement = () => {
      if (track.current && ref.current && document.body.contains(ref.current)) {
        const isRtl = getIsRtl(ref.current);
        const { insetInlineStart, insetBlockStart, inlineSize, blockSize } = getLogicalBoundingClientRect(track.current);
        const newX = (insetInlineStart + getScrollInlineStart(document.documentElement)) * (isRtl ? -1 : 1);
        const newY = insetBlockStart + document.documentElement.scrollTop;
        if (lastX !== newX || lastY !== newY) {
          ref.current.style.translate = `${newX}px ${newY}px`;
          lastX = newX;
          lastY = newY;
        }
        if (lastInlineSize !== inlineSize || lastBlockSize !== blockSize) {
          ref.current.style.width = `${inlineSize}px`;
          ref.current.style.height = `${blockSize}px`;
          lastInlineSize = inlineSize;
          lastBlockSize = blockSize;
        }
      }
      if (!cleanedUp) {
        requestAnimationFrame(updateElement);
      }
    };
    updateElement();
    return () => {
      cleanedUp = true;
    };
  }, [isDisabled, track]);
  return import_react3.default.createElement(
    Portal,
    { container },
    import_react3.default.createElement(
      "span",
      { ref, className: clsx_m_default(styles_css_default3["portal-overlay"], isDisabled && styles_css_default3["portal-overlay-disabled"]) },
      import_react3.default.createElement("span", { className: styles_css_default3["portal-overlay-contents"] }, children)
    )
  );
}

// node_modules/@cloudscape-design/components/internal/components/drag-handle-wrapper/index.js
var FORCED_POSITION_PROXIMITY_PX = 50;
var UAP_BUTTON_SIZE_PX = 40;
var DIRECTIONS_ORDER = ["block-end", "block-start", "inline-end", "inline-start"];
function DragHandleWrapper({ directions, tooltipText, children, onDirectionClick, triggerMode = "focus", initialShowButtons = false, controlledShowButtons = false, wrapperClassName, hideButtonsOnDrag, clickDragThreshold }) {
  const wrapperRef = (0, import_react4.useRef)(null);
  const dragHandleRef = (0, import_react4.useRef)(null);
  const [showTooltip, setShowTooltip] = (0, import_react4.useState)(false);
  const [uncontrolledShowButtons, setUncontrolledShowButtons] = (0, import_react4.useState)(initialShowButtons);
  const isPointerDown = (0, import_react4.useRef)(false);
  const initialPointerPosition = (0, import_react4.useRef)();
  const didPointerDrag = (0, import_react4.useRef)(false);
  const isDisabled = !directions["block-start"] && !directions["block-end"] && !directions["inline-start"] && !directions["inline-end"];
  const onWrapperFocusIn = (event) => {
    if (document.body.dataset.awsuiFocusVisible && !nodeContains(wrapperRef.current, event.relatedTarget)) {
      setShowTooltip(false);
      if (triggerMode === "focus") {
        setUncontrolledShowButtons(true);
      }
    }
  };
  const onWrapperFocusOut = (event) => {
    if (document.hasFocus() && !nodeContains(wrapperRef.current, event.relatedTarget)) {
      setUncontrolledShowButtons(false);
    }
  };
  (0, import_react4.useEffect)(() => {
    const controller = new AbortController();
    document.addEventListener("pointermove", (event) => {
      if (isPointerDown.current && initialPointerPosition.current && (event.clientX > initialPointerPosition.current.x + clickDragThreshold || event.clientX < initialPointerPosition.current.x - clickDragThreshold || event.clientY > initialPointerPosition.current.y + clickDragThreshold || event.clientY < initialPointerPosition.current.y - clickDragThreshold)) {
        didPointerDrag.current = true;
        if (hideButtonsOnDrag) {
          setUncontrolledShowButtons(false);
        }
      }
    }, { signal: controller.signal });
    const resetPointerDownState = () => {
      isPointerDown.current = false;
      initialPointerPosition.current = void 0;
    };
    document.addEventListener("pointercancel", () => {
      resetPointerDownState();
    }, { signal: controller.signal });
    document.addEventListener("pointerup", () => {
      if (isPointerDown.current && !didPointerDrag.current) {
        setUncontrolledShowButtons(true);
      }
      resetPointerDownState();
    }, { signal: controller.signal });
    return () => controller.abort();
  }, [clickDragThreshold, hideButtonsOnDrag]);
  const onHandlePointerDown = (event) => {
    isPointerDown.current = true;
    didPointerDrag.current = false;
    initialPointerPosition.current = { x: event.clientX, y: event.clientY };
    setShowTooltip(false);
  };
  const onTooltipGroupPointerEnter = () => {
    if (!isPointerDown.current) {
      setShowTooltip(true);
    }
  };
  const onTooltipGroupPointerLeave = () => {
    setShowTooltip(false);
  };
  const onDragHandleKeyDown = (event) => {
    if (event.key === "Escape") {
      setUncontrolledShowButtons(false);
    } else if (triggerMode === "keyboard-activate" && (event.key === "Enter" || event.key === " ")) {
      setUncontrolledShowButtons((prevShowButtons) => !prevShowButtons);
    } else if (event.key !== "Alt" && event.key !== "Control" && event.key !== "Meta" && event.key !== "Shift" && triggerMode === "focus") {
      setUncontrolledShowButtons(true);
    }
  };
  const showButtons = triggerMode === "controlled" ? controlledShowButtons : uncontrolledShowButtons;
  const [forcedPosition, setForcedPosition] = (0, import_react4.useState)(null);
  const directionsOrder = forcedPosition === "bottom" ? [...DIRECTIONS_ORDER].reverse() : DIRECTIONS_ORDER;
  const visibleDirections = directionsOrder.filter((dir) => directions[dir]);
  (0, import_react4.useEffect)(() => {
    if (!showButtons || !dragHandleRef.current) {
      setForcedPosition(null);
      return;
    }
    let frameId;
    const checkPosition = () => {
      if (!dragHandleRef.current) {
        return;
      }
      const rect = getLogicalBoundingClientRect(dragHandleRef.current);
      const conflicts = {
        "block-start": rect.insetBlockStart < FORCED_POSITION_PROXIMITY_PX,
        "block-end": window.innerHeight - rect.insetBlockEnd < FORCED_POSITION_PROXIMITY_PX,
        "inline-start": rect.insetInlineStart < FORCED_POSITION_PROXIMITY_PX,
        "inline-end": window.innerWidth - rect.insetInlineEnd < FORCED_POSITION_PROXIMITY_PX
      };
      if (visibleDirections.some((direction) => conflicts[direction])) {
        const hasEnoughSpaceAbove = rect.insetBlockStart > visibleDirections.length * UAP_BUTTON_SIZE_PX;
        setForcedPosition(hasEnoughSpaceAbove ? "top" : "bottom");
      } else {
        setForcedPosition(null);
      }
      frameId = requestAnimationFrame(checkPosition);
    };
    frameId = requestAnimationFrame(checkPosition);
    return () => {
      cancelAnimationFrame(frameId);
    };
  }, [showButtons, visibleDirections]);
  return import_react4.default.createElement(
    import_react4.default.Fragment,
    null,
    import_react4.default.createElement(
      "div",
      { className: clsx_m_default(styles_css_default4.root, styles_css_default3.contents), ref: wrapperRef, onFocus: onWrapperFocusIn, onBlur: onWrapperFocusOut },
      import_react4.default.createElement(
        "div",
        { className: styles_css_default3.contents, onPointerEnter: onTooltipGroupPointerEnter, onPointerLeave: onTooltipGroupPointerLeave },
        import_react4.default.createElement("div", { className: clsx_m_default(styles_css_default3["drag-handle"], wrapperClassName), ref: dragHandleRef, onPointerDown: onHandlePointerDown, onKeyDown: onDragHandleKeyDown }, children),
        !isDisabled && !showButtons && showTooltip && tooltipText && // Rendered in a portal but pointerenter/pointerleave events still propagate
        // up the React DOM tree, which is why it's placed in this nested context.
        import_react4.default.createElement(Tooltip, { trackRef: dragHandleRef, value: tooltipText, onDismiss: () => setShowTooltip(false) })
      )
    ),
    import_react4.default.createElement(PortalOverlay, { track: dragHandleRef, isDisabled: !showButtons }, visibleDirections.map((direction, index) => directions[direction] && import_react4.default.createElement(DirectionButton, { key: direction, show: !isDisabled && showButtons, direction, state: directions[direction], onClick: () => onDirectionClick === null || onDirectionClick === void 0 ? void 0 : onDirectionClick(direction), forcedPosition, forcedIndex: index })))
  );
}

// node_modules/@cloudscape-design/components/internal/utils/calculate-once.js
function calculateOnce(callback) {
  let result = void 0;
  return () => {
    if (result === void 0) {
      result = callback();
    }
    return result;
  };
}

// node_modules/@cloudscape-design/components/internal/utils/browser-scrollbar-size.js
var browserScrollbarSize = calculateOnce(() => {
  if (typeof document === "undefined") {
    return { width: 0, height: 0 };
  }
  const scrollDiv = document.createElement("div");
  scrollDiv.style.overflow = "scroll";
  scrollDiv.style.height = "100px";
  scrollDiv.style.width = "100px";
  scrollDiv.style.position = "absolute";
  scrollDiv.style.top = "-9999px";
  scrollDiv.style.left = "-9999px";
  document.body.appendChild(scrollDiv);
  const width = scrollDiv.offsetWidth - scrollDiv.clientWidth;
  const height = scrollDiv.offsetHeight - scrollDiv.clientHeight;
  document.body.removeChild(scrollDiv);
  return { width, height };
});

// node_modules/@cloudscape-design/components/internal/components/screenreader-only/index.js
var import_react5 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/screenreader-only/styles.css.js
import "/Users/hbaisani/Hub Explorations/node_modules/@cloudscape-design/components/internal/components/screenreader-only/styles.scoped.css";
var styles_css_default5 = {
  "root": "awsui_root_xttbq_1rjuy_145"
};

// node_modules/@cloudscape-design/components/internal/components/screenreader-only/index.js
function ScreenreaderOnly(props) {
  return import_react5.default.createElement("span", { ...props, className: clsx_m_default(styles_css_default5.root, props.className) });
}

// node_modules/@cloudscape-design/components/internal/hooks/use-intersection-observer/index.js
var import_react6 = __toESM(require_react());
function useIntersectionObserver({ initialState = false } = {}) {
  const observerRef = (0, import_react6.useRef)(null);
  const [isIntersecting, setIsIntersecting] = (0, import_react6.useState)(initialState);
  const ref = (0, import_react6.useCallback)((targetElement) => {
    if (typeof IntersectionObserver === "undefined") {
      return;
    }
    if (observerRef.current) {
      observerRef.current.disconnect();
    }
    if (targetElement) {
      let TopLevelIntersectionObserver = IntersectionObserver;
      try {
        if (window.top) {
          TopLevelIntersectionObserver = window.top.IntersectionObserver;
        }
      } catch {
      }
      observerRef.current = new TopLevelIntersectionObserver((entries) => {
        let latestEntry = entries[0];
        for (const entry of entries) {
          if (entry.time > latestEntry.time) {
            latestEntry = entry;
          }
        }
        setIsIntersecting(latestEntry.isIntersecting);
      });
      observerRef.current.observe(targetElement);
    }
  }, []);
  return { ref, isIntersecting };
}

export {
  DragHandleWrapper,
  browserScrollbarSize,
  ScreenreaderOnly,
  useIntersectionObserver
};
//# sourceMappingURL=chunk-PAPD5ADY.js.map
