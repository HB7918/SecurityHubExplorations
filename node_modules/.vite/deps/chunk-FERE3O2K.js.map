{
  "version": 3,
  "sources": ["../../src/internal/context/container-header.tsx", "../../src/container/use-sticky-header.ts"],
  "sourcesContent": ["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { createContext, useContext } from 'react';\n\ninterface ContainerHeaderContextProps {\n  isInContainer: boolean;\n}\n\nconst ContainerHeaderContext = createContext<ContainerHeaderContextProps>({ isInContainer: false });\nexport const ContainerHeaderContextProvider = ({ children }: { children?: React.ReactNode }) => {\n  return <ContainerHeaderContext.Provider value={{ isInContainer: true }}>{children}</ContainerHeaderContext.Provider>;\n};\nexport const useContainerHeader = () => {\n  const { isInContainer } = useContext(ContainerHeaderContext);\n  return isInContainer;\n};\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { createContext, RefObject, useCallback, useEffect, useLayoutEffect, useState } from 'react';\n\nimport { findUpUntil } from '@cloudscape-design/component-toolkit/dom';\n\nimport * as tokens from '../internal/generated/styles/tokens';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport globalVars from '../internal/styles/global-vars';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\n\ninterface StickyHeaderContextProps {\n  isStuck: boolean;\n  isStuckAtBottom: boolean;\n}\n\ninterface ComputeOffsetProps {\n  isMobile: boolean;\n  __stickyOffset?: number;\n  __mobileStickyOffset?: number;\n  hasInnerOverflowParents: boolean;\n  __additionalOffset?: boolean;\n}\n\nexport function computeOffset({\n  isMobile,\n  __stickyOffset,\n  __mobileStickyOffset,\n  hasInnerOverflowParents,\n  __additionalOffset,\n}: ComputeOffsetProps): string {\n  const localOffset = isMobile ? (__stickyOffset ?? 0) - (__mobileStickyOffset ?? 0) : (__stickyOffset ?? 0);\n  if (hasInnerOverflowParents || __stickyOffset !== undefined) {\n    return `${localOffset}px`;\n  }\n  const globalOffset = `var(${globalVars.stickyVerticalTopOffset}, 0px)`;\n\n  return `calc(${globalOffset} + ${localOffset}px + ${__additionalOffset ? tokens.spaceScaledS : '0px'})`;\n}\n\nexport const StickyHeaderContext = createContext<StickyHeaderContextProps>({\n  isStuck: false,\n  isStuckAtBottom: false,\n});\n\nexport const useStickyHeader = (\n  rootRef: RefObject<HTMLDivElement>,\n  headerRef: RefObject<HTMLDivElement>,\n  __stickyHeader?: boolean,\n  __stickyOffset?: number,\n  __mobileStickyOffset?: number,\n  __disableMobile?: boolean,\n  __additionalOffset = false\n) => {\n  const isMobile = useMobile();\n  const disableSticky = isMobile && __disableMobile;\n  const isSticky = !disableSticky && !!__stickyHeader;\n\n  // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n  const [hasInnerOverflowParents, setHasInnerOverflowParents] = useState(false);\n  const [isStuck, setIsStuck] = useState(false);\n  const [isStuckAtBottom, setIsStuckAtBottom] = useState(false);\n\n  useLayoutEffect(() => {\n    if (rootRef.current) {\n      const overflowParents = getOverflowParents(rootRef.current);\n      const mainElement = findUpUntil(rootRef.current, elem => elem.tagName === 'MAIN');\n\n      // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n\n  const computedOffset = computeOffset({\n    isMobile,\n    __stickyOffset,\n    __mobileStickyOffset,\n    hasInnerOverflowParents,\n    __additionalOffset,\n  });\n\n  const stickyStyles = isSticky\n    ? {\n        style: {\n          top: computedOffset,\n        },\n      }\n    : {};\n\n  // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n  const checkIfStuck = useCallback(\n    ({ isTrusted, target, type }) => {\n      if (type === 'resize' && target === window && !isTrusted) {\n        // The window size didn't actually change, it was a synthetic event\n        return;\n      }\n      if (rootRef.current && headerRef.current) {\n        const rootTopBorderWidth = parseFloat(getComputedStyle(rootRef.current).borderTopWidth) || 0;\n\n        // Using Math.round to adjust for rounding errors in floating-point arithmetic and timing issues\n        const rootTop = Math.round(rootRef.current.getBoundingClientRect().top + rootTopBorderWidth);\n        const headerTop = Math.round(headerRef.current.getBoundingClientRect().top);\n        if (rootTop < headerTop) {\n          setIsStuck(true);\n        } else {\n          setIsStuck(false);\n        }\n\n        const rootBottom = Math.round(rootRef.current.getBoundingClientRect().bottom - rootTopBorderWidth);\n        const headerBottom = Math.round(headerRef.current.getBoundingClientRect().bottom);\n        if (rootBottom <= headerBottom) {\n          setIsStuckAtBottom(true);\n        } else {\n          setIsStuckAtBottom(false);\n        }\n      }\n    },\n    [rootRef, headerRef]\n  );\n\n  useEffect(() => {\n    if (isSticky) {\n      const controller = new AbortController();\n      window.addEventListener('scroll', checkIfStuck, { capture: true, signal: controller.signal });\n      window.addEventListener('resize', checkIfStuck, { signal: controller.signal });\n      return () => {\n        controller.abort();\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky,\n    isStuck,\n    isStuckAtBottom,\n    stickyStyles,\n  };\n};\n"],
  "mappings": "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",
  "names": ["React", "import_react"]
}
