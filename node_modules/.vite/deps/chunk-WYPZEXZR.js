import {
  require_react_dom
} from "./chunk-BVI7NZOO.js";
import {
  require_react
} from "./chunk-4HAMFFQC.js";
import {
  __toESM
} from "./chunk-EQCVQC35.js";

// node_modules/clsx/dist/clsx.m.js
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  else for (t in e) e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length; ) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_m_default = clsx;

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/is-development.js
var isDevelopment = true;

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/logging.js
var messageCache = /* @__PURE__ */ new Set();
function warnOnce(component, message) {
  if (isDevelopment) {
    const warning = `[AwsUi] [${component}] ${message}`;
    if (!messageCache.has(warning)) {
      messageCache.add(warning);
      console.warn(warning);
    }
  }
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/use-merge-refs/index.js
var import_react = __toESM(require_react(), 1);
function useMergeRefs(...refs) {
  return (0, import_react.useMemo)(() => {
    if (refs.every((ref) => ref === null || ref === void 0)) {
      return null;
    }
    return (value) => {
      refs.forEach((ref) => {
        if (typeof ref === "function") {
          ref(value);
        } else if (ref !== null && ref !== void 0) {
          ref.current = value;
        }
      });
    };
  }, refs);
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/base-component/component-metadata.js
var import_react2 = __toESM(require_react(), 1);
var COMPONENT_METADATA_KEY = "__awsuiMetadata__";
function useComponentMetadata(componentName, packageMetadata, analyticsMetadata) {
  const elementRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    if (elementRef.current) {
      const pkgMetadata = typeof packageMetadata === "string" ? { version: packageMetadata } : packageMetadata;
      const node = elementRef.current;
      const metadata = {
        ...pkgMetadata,
        name: componentName
      };
      if (analyticsMetadata && Object.keys(analyticsMetadata).length > 0) {
        metadata.analytics = analyticsMetadata;
      }
      Object.freeze(metadata);
      Object.defineProperty(node, COMPONENT_METADATA_KEY, { value: metadata, writable: false, configurable: true });
    }
  });
  return elementRef;
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/base-component/component-metrics.js
var import_react3 = __toESM(require_react(), 1);

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/base-component/metrics/log-clients.js
var AWSUI_EVENT = "awsui";
function validateLength(value, maxLength) {
  return !value || value.length <= maxLength;
}
var CLogClient = class {
  /**
   * Sends metric but only if Console Platform client logging JS API is present in the page.
   */
  sendMetric(metricName, value, detail) {
    if (!metricName || !/^[a-zA-Z0-9_-]+$/.test(metricName)) {
      console.error(`Invalid metric name: ${metricName}`);
      return;
    }
    if (!validateLength(metricName, 1e3)) {
      console.error(`Metric name ${metricName} is too long`);
      return;
    }
    if (!validateLength(detail, 4e3)) {
      console.error(`Detail for metric ${metricName} is too long: ${detail}`);
      return;
    }
    const wasSent = new PanoramaClient().sendMetric({
      eventContext: metricName,
      eventDetail: detail,
      eventValue: `${value}`,
      timestamp: Date.now()
    });
    if (wasSent) {
      return;
    }
    const AWSC = this.findAWSC(window);
    if (typeof AWSC === "object" && typeof AWSC.Clog === "object" && typeof AWSC.Clog.log === "function") {
      AWSC.Clog.log(metricName, value, detail);
    }
  }
  findAWSC(currentWindow) {
    try {
      if (typeof (currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.AWSC) === "object") {
        return currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.AWSC;
      }
      if (!currentWindow || currentWindow.parent === currentWindow) {
        return void 0;
      }
      return this.findAWSC(currentWindow.parent);
    } catch {
      return void 0;
    }
  }
};
var PanoramaClient = class {
  /**
   * Sends metric but only if Console Platform client v2 logging JS API is present in the page.
   */
  sendMetric(metric) {
    const panorama = this.findPanorama(window);
    if (!panorama) {
      return false;
    }
    const payload = {
      eventType: AWSUI_EVENT,
      timestamp: Date.now(),
      ...metric,
      eventDetail: typeof metric.eventDetail === "object" ? JSON.stringify(metric.eventDetail) : metric.eventDetail,
      eventValue: typeof metric.eventValue === "object" ? JSON.stringify(metric.eventValue) : metric.eventValue
    };
    if (!validateLength(payload.eventDetail, 4e3)) {
      this.onMetricError(`Event detail for metric is too long: ${payload.eventDetail}`);
      return true;
    }
    if (!validateLength(payload.eventValue, 4e3)) {
      this.onMetricError(`Event value for metric is too long: ${payload.eventValue}`);
      return true;
    }
    if (!validateLength(payload.eventContext, 4e3)) {
      this.onMetricError(`Event context for metric is too long: ${payload.eventContext}`);
      return true;
    }
    panorama("trackCustomEvent", payload);
    return true;
  }
  onMetricError(message) {
    console.error(message);
    const panorama = this.findPanorama(window);
    if (panorama) {
      panorama("trackCustomEvent", {
        eventType: AWSUI_EVENT,
        eventContext: "awsui-metric-error",
        eventDetail: message.slice(0, 4e3),
        timestamp: Date.now()
      });
    }
  }
  findPanorama(currentWindow) {
    try {
      if (typeof (currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.panorama) === "function") {
        return currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.panorama;
      }
      const panoramaSymbol = Symbol.for("panorama");
      const symbolProperty = currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow[panoramaSymbol];
      if (typeof symbolProperty === "function") {
        return symbolProperty;
      }
      if (!currentWindow || currentWindow.parent === currentWindow) {
        return void 0;
      }
      return this.findPanorama(currentWindow.parent);
    } catch {
      return void 0;
    }
  }
};

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/base-component/metrics/formatters.js
function buildMetricDetail(detail, context) {
  const metricOrigin = typeof AWSUI_METRIC_ORIGIN !== "undefined" ? AWSUI_METRIC_ORIGIN : "main";
  const detailObject = {
    o: metricOrigin,
    t: context.theme,
    // React is the only framework we're using.
    f: "react",
    // Remove spaces from the version string for compactness
    v: context.packageVersion.replace(/\s/g, ""),
    ...detail
  };
  return jsonStringify(detailObject);
}
function buildComponentMetricDetail({ componentName, action, configuration, packageSource }, context) {
  return buildMetricDetail({
    a: action,
    s: componentName,
    p: packageSource,
    c: configuration
  }, context);
}
function jsonStringify(detailObject) {
  return JSON.stringify(detailObject, detailSerializer);
}
function detailSerializer(key, value) {
  if (typeof value === "number" && !Number.isFinite(value)) {
    return `${value}`;
  }
  return value;
}
function getMajorVersion(versionString) {
  const majorVersionMatch = versionString.match(/^(\d+\.\d+)/);
  return majorVersionMatch ? majorVersionMatch[1].replace(".", "") : "";
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/base-component/metrics/metrics.js
var oneTimeMetrics = /* @__PURE__ */ new Set();
var Metrics = class {
  constructor(...args) {
    this.clog = new CLogClient();
    this.panorama = new PanoramaClient();
    if (args.length === 1) {
      this.context = args[0];
    } else {
      const [packageSource, packageVersion] = args;
      this.context = { packageSource, packageVersion, theme: "unknown" };
    }
  }
  sendComponentMetric(metric) {
    this.sendMetricOnce(`awsui_${metric.componentName}_${this.context.theme.charAt(0)}${getMajorVersion(this.context.packageVersion)}`, 1, buildComponentMetricDetail(metric, this.context));
  }
  /*
   * Calls Console Platform's client logging only the first time the provided metricName is used.
   * Subsequent calls with the same metricName are ignored.
   */
  sendMetricOnce(metricName, value, detail) {
    const key = [metricName + value + detail].join("|");
    if (!oneTimeMetrics.has(key)) {
      this.clog.sendMetric(metricName, value, detail);
      oneTimeMetrics.add(key);
    }
  }
  /**
   * Calls Console Platform's client v2 logging JS API with provided metric name and detail.
   * Does nothing if Console Platform client logging JS is not present in page.
   */
  sendPanoramaMetric(metric) {
    this.panorama.sendMetric(metric);
  }
  sendOpsMetricObject(metricName, detail) {
    this.sendMetricOnce(metricName, 1, buildMetricDetail(detail, this.context));
  }
  sendOpsMetricValue(metricName, value) {
    this.sendMetricOnce(metricName, value);
  }
  /*
   * Reports a metric value 1 to Console Platform's client logging service to indicate that the
   * component was loaded. The component load event will only be reported as used to client logging
   * service once per page view.
   */
  logComponentsLoaded() {
    this.sendComponentMetric({ componentName: this.context.packageSource, action: "loaded" });
  }
  /*
   * Reports a metric value 1 to Console Platform's client logging service to indicate that the
   * component was used in the page.  A component will only be reported as used to client logging
   * service once per page view.
   */
  logComponentUsed(componentName, configuration) {
    this.sendComponentMetric({
      action: "used",
      componentName,
      configuration,
      packageSource: this.context.packageSource
    });
  }
};

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/base-component/component-metrics.js
function useComponentMetrics(componentName, settings, configuration = { props: {} }) {
  (0, import_react3.useEffect)(() => {
    const metrics2 = new Metrics(settings);
    if (typeof window !== "undefined") {
      metrics2.sendOpsMetricValue("awsui-viewport-width", window.innerWidth || 0);
      metrics2.sendOpsMetricValue("awsui-viewport-height", window.innerHeight || 0);
    }
    metrics2.logComponentsLoaded();
    metrics2.logComponentUsed(componentName.toLowerCase(), configuration);
  }, []);
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/base-component/init-awsui-versions.js
function initAwsUiVersions(source, packageVersion) {
  if (typeof window !== "undefined") {
    if (!window.awsuiVersions) {
      window.awsuiVersions = {};
    }
    if (!window.awsuiVersions[source]) {
      window.awsuiVersions[source] = [];
    }
    window.awsuiVersions[source].push(packageVersion);
  }
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/container-queries/use-resize-observer.js
var import_react_dom = __toESM(require_react_dom(), 1);
var import_react5 = __toESM(require_react(), 1);

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/stable-callback/index.js
var import_react4 = __toESM(require_react(), 1);
function useStableCallback(fn) {
  const ref = (0, import_react4.useRef)();
  (0, import_react4.useEffect)(() => {
    ref.current = fn;
  });
  return (0, import_react4.useCallback)((...args) => {
    var _a2;
    return (_a2 = ref.current) === null || _a2 === void 0 ? void 0 : _a2.call(ref, ...args);
  }, []);
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/container-queries/use-resize-observer.js
function useResizeObserver(elementRef, onObserve) {
  const stableOnObserve = useStableCallback(onObserve);
  (0, import_react5.useLayoutEffect)(
    () => {
      const element = typeof elementRef === "function" ? elementRef() : elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;
      if (element) {
        const rect = element.getBoundingClientRect();
        onObserve(convertElementToEntry(element, rect));
      }
    },
    // This effect is only needed for the first render to provide a synchronous update.
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  (0, import_react5.useEffect)(() => {
    const element = typeof elementRef === "function" ? elementRef() : elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;
    if (element && typeof ResizeObserver !== "undefined") {
      let connected = true;
      const observer = new ResizeObserver((entries) => {
        if (connected) {
          (0, import_react_dom.unstable_batchedUpdates)(() => {
            stableOnObserve(convertResizeObserverEntry(entries[0]));
          });
        }
      });
      observer.observe(element, { box: "border-box" });
      return () => {
        connected = false;
        observer.disconnect();
      };
    }
  }, [elementRef, stableOnObserve]);
}
function convertResizeObserverEntry(entry) {
  return {
    target: entry.target,
    contentBoxWidth: entry.contentBoxSize[0].inlineSize,
    contentBoxHeight: entry.contentBoxSize[0].blockSize,
    borderBoxWidth: entry.borderBoxSize[0].inlineSize,
    borderBoxHeight: entry.borderBoxSize[0].blockSize
  };
}
function convertElementToEntry(element, rect) {
  const computedStyle = window.getComputedStyle(element);
  const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
  const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
  const paddingTop = parseFloat(computedStyle.paddingTop) || 0;
  const paddingBottom = parseFloat(computedStyle.paddingBottom) || 0;
  const borderLeft = parseFloat(computedStyle.borderLeftWidth) || 0;
  const borderRight = parseFloat(computedStyle.borderRightWidth) || 0;
  const borderTop = parseFloat(computedStyle.borderTopWidth) || 0;
  const borderBottom = parseFloat(computedStyle.borderBottomWidth) || 0;
  return {
    target: element,
    contentBoxWidth: rect.width - paddingLeft - paddingRight - borderLeft - borderRight,
    contentBoxHeight: rect.height - paddingTop - paddingBottom - borderTop - borderBottom,
    borderBoxWidth: rect.width,
    borderBoxHeight: rect.height
  };
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/singleton-handler/index.js
var import_react6 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);
function createSingletonHandler(factory) {
  const listeners = /* @__PURE__ */ new Set();
  const callback = (value) => {
    (0, import_react_dom2.unstable_batchedUpdates)(() => {
      for (const listener of listeners) {
        listener(value);
      }
    });
  };
  let cleanup;
  return function useSingleton(listener) {
    (0, import_react6.useEffect)(() => {
      if (listeners.size === 0) {
        cleanup = factory(callback);
      }
      listeners.add(listener);
      return () => {
        listeners.delete(listener);
        if (listeners.size === 0) {
          cleanup();
          cleanup = void 0;
        }
      };
    }, []);
  };
}
function createSingletonState({ factory, initialState }) {
  const useSingleton = createSingletonHandler(factory);
  return function useSingletonState() {
    const [state, setState] = (0, import_react6.useState)(initialState);
    useSingleton(setState);
    return state;
  };
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/visual-mode/index.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/@cloudscape-design/component-toolkit/mjs/dom/element-types.js
function isNode(target) {
  return target instanceof Node || target !== null && typeof target === "object" && "nodeType" in target && typeof target.nodeType === "number" && "nodeName" in target && typeof target.nodeName === "string" && "parentNode" in target && typeof target.parentNode === "object";
}
function isHTMLElement(target) {
  return target instanceof HTMLElement || isNode(target) && target.nodeType === Node.ELEMENT_NODE && "style" in target && typeof target.style === "object" && typeof target.ownerDocument === "object" && !isSVGElement(target);
}
function isSVGElement(target) {
  return target instanceof SVGElement || isNode(target) && target.nodeType === Node.ELEMENT_NODE && "ownerSVGElement" in target && typeof target.ownerSVGElement === "object";
}

// node_modules/@cloudscape-design/component-toolkit/mjs/dom/find-up-until.js
function findUpUntil(from, test) {
  let current = from;
  while (current && !test(current)) {
    current = current.parentElement;
    while (current && !isHTMLElement(current)) {
      current = current.parentElement;
    }
  }
  return current;
}

// node_modules/@cloudscape-design/component-toolkit/mjs/dom/node-contains.js
function nodeContains(parent, descendant) {
  if (!parent || !descendant || !isNode(descendant)) {
    return false;
  }
  return parent.contains(descendant);
}

// node_modules/@cloudscape-design/component-toolkit/mjs/dom/node-belongs.js
function nodeBelongs(container, target) {
  var _a2;
  if (!isNode(target)) {
    return false;
  }
  const portal = findUpUntil(target, (node) => node === container || isHTMLElement(node) && !!node.dataset.awsuiReferrerId);
  if (portal && portal === container) {
    return true;
  }
  const referrer = isHTMLElement(portal) ? document.getElementById((_a2 = portal.dataset.awsuiReferrerId) !== null && _a2 !== void 0 ? _a2 : "") : null;
  return referrer ? nodeContains(container, referrer) : nodeContains(container, target);
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/global-flags/index.js
var awsuiVisualRefreshFlag = Symbol.for("awsui-visual-refresh-flag");
var awsuiGlobalFlagsSymbol = Symbol.for("awsui-global-flags");
var getTopWindow = () => {
  return window.top;
};
function getGlobal() {
  return typeof window !== "undefined" ? window : globalThis;
}
function readFlag(holder, flagName) {
  var _a2;
  return (_a2 = holder === null || holder === void 0 ? void 0 : holder[awsuiGlobalFlagsSymbol]) === null || _a2 === void 0 ? void 0 : _a2[flagName];
}
var getGlobalFlag = (flagName) => {
  try {
    const ownFlag = readFlag(getGlobal(), flagName);
    if (ownFlag !== void 0) {
      return ownFlag;
    }
    return readFlag(getTopWindow(), flagName);
  } catch {
    return void 0;
  }
};

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/utils/safe-match-media.js
function safeMatchMedia(element, query) {
  var _a2, _b, _c, _d;
  try {
    const targetWindow = (_b = (_a2 = element.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView) !== null && _b !== void 0 ? _b : window;
    return (_d = (_c = targetWindow.matchMedia) === null || _c === void 0 ? void 0 : _c.call(targetWindow, query).matches) !== null && _d !== void 0 ? _d : false;
  } catch (error) {
    console.warn(error);
    return false;
  }
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/visual-mode/index.js
function isMotionDisabled(element) {
  return !!findUpUntil(element, (node) => node.classList.contains("awsui-motion-disabled")) || safeMatchMedia(element, "(prefers-reduced-motion: reduce)");
}
function useModeDetector(elementRef, detector, initialValue) {
  const [value, setValue] = (0, import_react7.useState)(initialValue);
  useMutationObserver(elementRef, (node) => {
    const newValue = detector(node);
    if (newValue !== value) {
      setValue(newValue);
    }
  });
  return value;
}
function detectCurrentMode(node) {
  const darkModeParent = findUpUntil(node, (node2) => node2.classList.contains("awsui-polaris-dark-mode") || node2.classList.contains("awsui-dark-mode"));
  return darkModeParent ? "dark" : "light";
}
function detectDensityMode(node) {
  const compactModeParent = findUpUntil(node, (node2) => node2.classList.contains("awsui-polaris-compact-mode") || node2.classList.contains("awsui-compact-mode"));
  return compactModeParent ? "compact" : "comfortable";
}
function useCurrentMode(elementRef) {
  return useModeDetector(elementRef, detectCurrentMode, "light");
}
function useDensityMode(elementRef) {
  return useModeDetector(elementRef, detectDensityMode, "comfortable");
}
function useReducedMotion(elementRef) {
  return useModeDetector(elementRef, isMotionDisabled, false);
}
var useMutationSingleton = createSingletonHandler((handler) => {
  const observer = new MutationObserver(() => handler());
  observer.observe(document.body, { attributes: true, subtree: true });
  return () => observer.disconnect();
});
function useMutationObserver(elementRef, onChange) {
  const handler = useStableCallback(() => {
    if (elementRef.current) {
      onChange(elementRef.current);
    }
  });
  useMutationSingleton(handler);
  (0, import_react7.useEffect)(() => {
    handler();
  }, [handler]);
}
var visualRefreshState = void 0;
function detectVisualRefreshClassName() {
  return typeof document !== "undefined" && !!document.querySelector(".awsui-visual-refresh");
}
function detectVisualRefreshFlag() {
  var _a2, _b;
  const global = getGlobal();
  return (_b = (_a2 = global === null || global === void 0 ? void 0 : global[awsuiVisualRefreshFlag]) === null || _a2 === void 0 ? void 0 : _a2.call(global)) !== null && _b !== void 0 ? _b : false;
}
function useRuntimeVisualRefresh() {
  if (visualRefreshState === void 0) {
    visualRefreshState = detectVisualRefreshClassName();
    if (!visualRefreshState) {
      if (detectVisualRefreshFlag()) {
        visualRefreshState = true;
        if (typeof document !== "undefined") {
          document.body.classList.add("awsui-visual-refresh");
        }
      }
    }
  }
  if (isDevelopment) {
    const newVisualRefreshState = detectVisualRefreshClassName() || detectVisualRefreshFlag();
    if (newVisualRefreshState !== visualRefreshState) {
      warnOnce("Visual Refresh", "Dynamic visual refresh change detected. This is not supported. Make sure `awsui-visual-refresh` is attached to the `<body>` element before initial React render");
    }
  }
  return visualRefreshState;
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/direction/index.js
function getIsRtl(element) {
  if (!element) {
    return false;
  }
  return getComputedStyle(element).direction === "rtl";
}
function getOffsetInlineStart(element) {
  var _a2, _b;
  const offsetParentWidth = (_b = (_a2 = element.offsetParent) === null || _a2 === void 0 ? void 0 : _a2.clientWidth) !== null && _b !== void 0 ? _b : 0;
  return getIsRtl(element) ? offsetParentWidth - element.offsetWidth - element.offsetLeft : element.offsetLeft;
}
function getScrollInlineStart(element) {
  return getIsRtl(element) ? Math.floor(element.scrollLeft) * -1 : Math.ceil(element.scrollLeft);
}
function getLogicalClientX(event, IsRtl) {
  return IsRtl ? document.documentElement.clientWidth - event.clientX : event.clientX;
}
function getLogicalBoundingClientRect(element) {
  const boundingClientRect = element.getBoundingClientRect();
  const blockSize = boundingClientRect.height;
  const inlineSize = boundingClientRect.width;
  const insetBlockStart = boundingClientRect.top;
  const insetBlockEnd = boundingClientRect.bottom;
  const insetInlineStart = getIsRtl(element) ? document.documentElement.clientWidth - boundingClientRect.right : boundingClientRect.left;
  const insetInlineEnd = insetInlineStart + inlineSize;
  return {
    blockSize,
    inlineSize,
    insetBlockStart,
    insetBlockEnd,
    insetInlineStart,
    insetInlineEnd
  };
}
function getLogicalPageX(event) {
  return event.target instanceof HTMLElement && getIsRtl(event.target) ? document.documentElement.clientWidth - event.pageX : event.pageX;
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/focus-visible/index.js
var import_react8 = __toESM(require_react(), 1);

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/keycode.js
var KeyCode;
(function(KeyCode2) {
  KeyCode2[KeyCode2["pageUp"] = 33] = "pageUp";
  KeyCode2[KeyCode2["pageDown"] = 34] = "pageDown";
  KeyCode2[KeyCode2["end"] = 35] = "end";
  KeyCode2[KeyCode2["home"] = 36] = "home";
  KeyCode2[KeyCode2["backspace"] = 8] = "backspace";
  KeyCode2[KeyCode2["space"] = 32] = "space";
  KeyCode2[KeyCode2["down"] = 40] = "down";
  KeyCode2[KeyCode2["left"] = 37] = "left";
  KeyCode2[KeyCode2["right"] = 39] = "right";
  KeyCode2[KeyCode2["up"] = 38] = "up";
  KeyCode2[KeyCode2["escape"] = 27] = "escape";
  KeyCode2[KeyCode2["enter"] = 13] = "enter";
  KeyCode2[KeyCode2["tab"] = 9] = "tab";
  KeyCode2[KeyCode2["shift"] = 16] = "shift";
  KeyCode2[KeyCode2["control"] = 17] = "control";
  KeyCode2[KeyCode2["alt"] = 18] = "alt";
  KeyCode2[KeyCode2["meta"] = 91] = "meta";
})(KeyCode || (KeyCode = {}));
function isModifierKey(event) {
  return [KeyCode.shift, KeyCode.alt, KeyCode.control, KeyCode.meta].includes(event.keyCode);
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/focus-visible/index.js
var frames = /* @__PURE__ */ new Map();
function setIsKeyboard(active) {
  if (active) {
    for (const currentDocument of frames.keys()) {
      currentDocument.body.setAttribute("data-awsui-focus-visible", "true");
    }
  } else {
    for (const currentDocument of frames.keys()) {
      currentDocument.body.removeAttribute("data-awsui-focus-visible");
    }
  }
}
function handleMousedown() {
  setIsKeyboard(false);
}
function handleKeydown(event) {
  if (!isModifierKey(event)) {
    setIsKeyboard(true);
  }
}
function addListeners(currentDocument) {
  const abortController = new AbortController();
  currentDocument.addEventListener("mousedown", handleMousedown, { signal: abortController.signal });
  currentDocument.addEventListener("keydown", handleKeydown, { signal: abortController.signal });
  return abortController;
}
function useFocusVisible(componentRef) {
  (0, import_react8.useEffect)(() => {
    var _a2, _b;
    const currentDocument = (_b = (_a2 = componentRef === null || componentRef === void 0 ? void 0 : componentRef.current) === null || _a2 === void 0 ? void 0 : _a2.ownerDocument) !== null && _b !== void 0 ? _b : document;
    let frame = frames.get(currentDocument);
    if (frame) {
      frame.componentsCount++;
    } else {
      const abortController = addListeners(currentDocument);
      frame = { componentsCount: 1, abortController };
      frames.set(currentDocument, frame);
    }
    return () => {
      frame.componentsCount--;
      if (frame.componentsCount === 0) {
        frame.abortController.abort();
        frames.delete(currentDocument);
      }
    };
  }, [componentRef]);
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/single-tab-stop/index.js
var import_react10 = __toESM(require_react(), 1);

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/use-effect-on-update/index.js
var import_react9 = __toESM(require_react(), 1);
function useEffectOnUpdate(callback, deps) {
  const isFirstRender = (0, import_react9.useRef)(true);
  (0, import_react9.useEffect)(() => {
    if (isFirstRender.current) {
      isFirstRender.current = false;
    } else {
      return callback();
    }
  }, deps);
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/single-tab-stop/index.js
var defaultValue = {
  navigationActive: false,
  registerFocusable: () => () => {
  },
  resetFocusTarget: () => {
  }
};
var SingleTabStopNavigationContext = (0, import_react10.createContext)(defaultValue);
function useSingleTabStopNavigation(focusable, options) {
  var _a2;
  const { navigationActive: contextNavigationActive, registerFocusable } = (0, import_react10.useContext)(SingleTabStopNavigationContext);
  const [focusTargetActive, setFocusTargetActive] = (0, import_react10.useState)(false);
  const navigationDisabled = (options === null || options === void 0 ? void 0 : options.tabIndex) && (options === null || options === void 0 ? void 0 : options.tabIndex) < 0;
  const navigationActive = contextNavigationActive && !navigationDisabled;
  (0, import_react10.useLayoutEffect)(() => {
    if (navigationActive && focusable && focusable.current) {
      const unregister = registerFocusable(focusable.current, (isFocusable2) => setFocusTargetActive(isFocusable2));
      return () => unregister();
    }
  });
  let tabIndex = options === null || options === void 0 ? void 0 : options.tabIndex;
  if (navigationActive) {
    tabIndex = !focusTargetActive ? -1 : (_a2 = options === null || options === void 0 ? void 0 : options.tabIndex) !== null && _a2 !== void 0 ? _a2 : 0;
  }
  return { navigationActive, tabIndex };
}
function SingleTabStopNavigationReset({ children }) {
  return import_react10.default.createElement(SingleTabStopNavigationContext.Provider, { value: defaultValue }, children);
}
var SingleTabStopNavigationProvider = (0, import_react10.forwardRef)(({ navigationActive, children, getNextFocusTarget, isElementSuppressed, onRegisterFocusable, onUnregisterActive }, ref) => {
  const focusables = (0, import_react10.useRef)(/* @__PURE__ */ new Set());
  const focusHandlers = (0, import_react10.useRef)(/* @__PURE__ */ new Map());
  const focusablesState = (0, import_react10.useRef)(/* @__PURE__ */ new WeakMap());
  const focusTarget = (0, import_react10.useRef)(null);
  function onUnregisterFocusable(focusableElement) {
    const isUnregisteringFocusedNode = nodeBelongs(focusableElement, document.activeElement);
    if (isUnregisteringFocusedNode) {
      setTimeout(() => onUnregisterActive === null || onUnregisterActive === void 0 ? void 0 : onUnregisterActive(focusableElement), 0);
    }
  }
  function registerFocusable(focusableElement, changeHandler) {
    const parentUnregister = parentContext.registerFocusable(focusableElement, changeHandler);
    focusables.current.add(focusableElement);
    focusHandlers.current.set(focusableElement, changeHandler);
    const isFocusable2 = !!focusablesState.current.get(focusableElement);
    const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));
    if (newIsFocusable !== isFocusable2) {
      focusablesState.current.set(focusableElement, newIsFocusable);
      changeHandler(newIsFocusable);
    }
    onRegisterFocusable === null || onRegisterFocusable === void 0 ? void 0 : onRegisterFocusable(focusableElement);
    return () => {
      parentUnregister();
      unregisterFocusable(focusableElement);
    };
  }
  function unregisterFocusable(focusableElement) {
    focusables.current.delete(focusableElement);
    focusHandlers.current.delete(focusableElement);
    onUnregisterFocusable === null || onUnregisterFocusable === void 0 ? void 0 : onUnregisterFocusable(focusableElement);
  }
  function updateFocusTarget(forceUpdate = false) {
    var _a2;
    focusTarget.current = getNextFocusTarget();
    for (const focusableElement of focusables.current) {
      const isFocusable2 = (_a2 = focusablesState.current.get(focusableElement)) !== null && _a2 !== void 0 ? _a2 : false;
      const newIsFocusable = focusTarget.current === focusableElement || !!(isElementSuppressed === null || isElementSuppressed === void 0 ? void 0 : isElementSuppressed(focusableElement));
      if (newIsFocusable !== isFocusable2 || forceUpdate) {
        focusablesState.current.set(focusableElement, newIsFocusable);
        focusHandlers.current.get(focusableElement)(newIsFocusable);
      }
    }
  }
  function resetFocusTarget() {
    updateFocusTarget(true);
  }
  function getFocusTarget() {
    return focusTarget.current;
  }
  function isRegistered(element) {
    return focusables.current.has(element);
  }
  (0, import_react10.useImperativeHandle)(ref, () => ({ updateFocusTarget, getFocusTarget, isRegistered }));
  const parentContext = (0, import_react10.useContext)(SingleTabStopNavigationContext);
  const value = parentContext.navigationActive ? parentContext : { navigationReset: false, navigationActive, registerFocusable, updateFocusTarget, resetFocusTarget };
  useEffectOnUpdate(() => {
    if (parentContext.navigationActive) {
      parentContext.resetFocusTarget();
    } else {
      resetFocusTarget();
    }
  }, [parentContext.navigationActive]);
  return import_react10.default.createElement(SingleTabStopNavigationContext.Provider, { value }, children);
});

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/focus-lock-utils/utils.js
var tabbables = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
].join(",");

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/portal/index.js
var import_react11 = __toESM(require_react(), 1);
var import_react_dom3 = __toESM(require_react_dom(), 1);
function manageDefaultContainer(setState) {
  const newContainer = document.createElement("div");
  document.body.appendChild(newContainer);
  setState(newContainer);
  return () => {
    document.body.removeChild(newContainer);
  };
}
function manageAsyncContainer(getContainer, removeContainer, setState) {
  let newContainer = null;
  const abortController = new AbortController();
  getContainer({ abortSignal: abortController.signal }).then((container) => {
    if (abortController.signal.aborted) {
      return;
    }
    newContainer = container;
    setState(container);
  }, (error) => {
    console.warn("[AwsUi] [portal]: failed to load portal root", error);
  });
  return () => {
    abortController.abort();
    removeContainer(newContainer);
  };
}
function Portal({ container, getContainer, removeContainer, children }) {
  const [activeContainer, setActiveContainer] = (0, import_react11.useState)(container !== null && container !== void 0 ? container : null);
  (0, import_react11.useLayoutEffect)(() => {
    if (container) {
      setActiveContainer(container);
      return;
    }
    if (isDevelopment) {
      if (getContainer && !removeContainer) {
        warnOnce("portal", "`removeContainer` is required when `getContainer` is provided");
      }
      if (!getContainer && removeContainer) {
        warnOnce("portal", "`getContainer` is required when `removeContainer` is provided");
      }
    }
    if (getContainer && removeContainer) {
      return manageAsyncContainer(getContainer, removeContainer, setActiveContainer);
    }
    return manageDefaultContainer(setActiveContainer);
  }, [container, getContainer, removeContainer]);
  return activeContainer && (0, import_react_dom3.createPortal)(children, activeContainer);
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/use-unique-id/index.js
var import_react12 = __toESM(require_react(), 1);
var _a;
var counter = 0;
var useRandomId = () => {
  const idRef = (0, import_react12.useRef)(null);
  if (!idRef.current) {
    idRef.current = `${counter++}-${Date.now()}-${Math.round(Math.random() * 1e4)}`;
  }
  return idRef.current;
};
var useId = (_a = import_react12.default.useId) !== null && _a !== void 0 ? _a : useRandomId;
function useUniqueId(prefix) {
  return `${prefix ? prefix : ""}` + useId();
}

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/track-by/index.js
var getTrackableValue = (trackBy, item) => {
  if (!trackBy) {
    return item;
  }
  if (typeof trackBy === "function") {
    return trackBy(item);
  }
  return item[trackBy];
};

// node_modules/@cloudscape-design/component-toolkit/mjs/internal/selection-tree/index.js
var ROOT_KEY = Symbol("selection-tree-root");
var SelectionTree = class _SelectionTree {
  constructor(roots, treeProps, state) {
    this.itemKeyToItem = /* @__PURE__ */ new Map();
    this.itemToggleState = /* @__PURE__ */ new Set();
    this.itemProjectedSelectionState = /* @__PURE__ */ new Set();
    this.itemProjectedParentSelectionState = /* @__PURE__ */ new Set();
    this.itemProjectedIndeterminateState = /* @__PURE__ */ new Set();
    this.itemKeyToSelectedCount = /* @__PURE__ */ new Map();
    this.selectedItems = new Array();
    this.isItemSelected = (item) => this.itemProjectedSelectionState.has(this.getKey(item));
    this.isItemIndeterminate = (item) => this.itemProjectedIndeterminateState.has(this.getKey(item));
    this.isAllItemsSelected = () => this.itemProjectedSelectionState.has(ROOT_KEY) && !this.itemProjectedIndeterminateState.has(ROOT_KEY);
    this.isAllItemsIndeterminate = () => this.itemProjectedIndeterminateState.has(ROOT_KEY);
    this.getSelectedItemsCount = (item) => {
      var _a2;
      return (_a2 = this.itemKeyToSelectedCount.get(this.getKey(item))) !== null && _a2 !== void 0 ? _a2 : 0;
    };
    this.getSelectedItems = () => this.selectedItems;
    this.getState = () => {
      const inverted = this.itemToggleState.has(ROOT_KEY);
      const toggledItems = [];
      for (const itemKey of Array.from(this.itemToggleState)) {
        const item = this.getItemForKey(itemKey);
        if (item) {
          toggledItems.push(item);
        }
      }
      return { inverted, toggledItems };
    };
    this.toggleAll = () => {
      return this.isAllItemsSelected() ? new _SelectionTree(this.roots, this.treeProps, { inverted: false, toggledItems: [] }) : new _SelectionTree(this.roots, this.treeProps, { inverted: true, toggledItems: [] });
    };
    this.toggleSome = (requestedItems) => {
      const clone = this.clone();
      const lastItemKey = clone.getKey(requestedItems[requestedItems.length - 1]);
      const isParentSelected = clone.itemProjectedParentSelectionState.has(lastItemKey);
      const isSelected = clone.itemProjectedSelectionState.has(lastItemKey);
      const isIndeterminate = clone.itemProjectedIndeterminateState.has(lastItemKey);
      const nextIsSelected = !(isSelected && !isIndeterminate);
      const nextIsSelfSelected = isParentSelected && !nextIsSelected || !isParentSelected && nextIsSelected;
      for (const requested of requestedItems) {
        clone.unselectDeep(requested);
        if (nextIsSelfSelected) {
          clone.itemToggleState.add(this.getKey(requested));
        }
      }
      clone.computeState();
      return clone;
    };
    this.invertAll = () => {
      const clone = this.clone();
      clone.toggleKey(ROOT_KEY);
      clone.roots.forEach((item) => clone.toggleKey(clone.getKey(item)));
      clone.computeState();
      return clone;
    };
    this.invertOne = (item) => {
      const clone = this.clone();
      clone.toggleKey(clone.getKey(item));
      clone.treeProps.getChildren(item).forEach((child) => clone.toggleKey(clone.getKey(child)));
      clone.computeState();
      return clone;
    };
    this.toggleKey = (key) => {
      if (this.itemToggleState.has(key)) {
        this.itemToggleState.delete(key);
      } else {
        this.itemToggleState.add(key);
      }
    };
    this.unselectDeep = (item) => {
      this.itemToggleState.delete(this.getKey(item));
      this.treeProps.getChildren(item).forEach((child) => this.unselectDeep(child));
    };
    this.roots = roots;
    this.treeProps = treeProps;
    if (state.inverted) {
      this.itemToggleState.add(ROOT_KEY);
    }
    for (const item of state.toggledItems) {
      this.itemToggleState.add(this.getKey(item));
    }
    const traverse = (item) => {
      this.itemKeyToItem.set(this.getKey(item), item);
      treeProps.getChildren(item).forEach(traverse);
    };
    roots.forEach(traverse);
    this.computeState();
  }
  computeState() {
    var _a2, _b;
    this.itemProjectedSelectionState = /* @__PURE__ */ new Set();
    this.itemProjectedIndeterminateState = /* @__PURE__ */ new Set();
    this.itemProjectedParentSelectionState = /* @__PURE__ */ new Set();
    this.itemKeyToSelectedCount = /* @__PURE__ */ new Map();
    this.selectedItems = [];
    const selectionBuckets = /* @__PURE__ */ new Map();
    const createSelectionBuckets = (item, level) => {
      var _a3;
      const itemKey = this.getKey(item);
      const levelBuckets = (_a3 = selectionBuckets.get(level)) !== null && _a3 !== void 0 ? _a3 : [];
      const children = this.treeProps.getChildren(item);
      const bucket = [itemKey];
      for (const child of children) {
        bucket.push(this.getKey(child));
        createSelectionBuckets(child, level + 1);
      }
      levelBuckets.push(bucket);
      selectionBuckets.set(level, levelBuckets);
    };
    const rootBucket = [ROOT_KEY];
    for (const item of this.roots) {
      rootBucket.push(this.getKey(item));
      createSelectionBuckets(item, 1);
    }
    selectionBuckets.set(0, [rootBucket]);
    const selectionBucketEntries = Array.from(selectionBuckets.entries()).sort(([a], [b]) => b - a).flatMap(([, v]) => v);
    for (const bucket of selectionBucketEntries) {
      if (bucket.length === 1) {
        continue;
      }
      let selectedCount = 0;
      for (let i = bucket.length - 1; i >= 0; i--) {
        if (this.itemToggleState.has(bucket[i])) {
          selectedCount++;
        } else {
          break;
        }
      }
      if (((_b = (_a2 = this.treeProps).isComplete) === null || _b === void 0 ? void 0 : _b.call(_a2, this.getItemForKey(bucket[0]))) === false) {
        continue;
      }
      if (selectedCount === bucket.length - 1 && !this.itemToggleState.has(bucket[0])) {
        bucket.forEach((itemKey) => this.itemToggleState.delete(itemKey));
        this.itemToggleState.add(bucket[0]);
      }
      if (selectedCount === bucket.length) {
        bucket.forEach((itemKey) => this.itemToggleState.delete(itemKey));
      }
    }
    const setItemProjectedSelection = (item, inheritedSelected) => {
      const itemKey = this.getKey(item);
      const isSelfSelected = this.itemToggleState.has(itemKey);
      const isSelected = isSelfSelected && !inheritedSelected || !isSelfSelected && inheritedSelected;
      if (isSelected) {
        this.itemProjectedSelectionState.add(itemKey);
      }
      if (inheritedSelected) {
        this.itemProjectedParentSelectionState.add(itemKey);
      }
      this.treeProps.getChildren(item).forEach((child) => setItemProjectedSelection(child, isSelected));
    };
    this.roots.forEach((item) => {
      const isRootSelected = this.itemToggleState.has(ROOT_KEY);
      if (isRootSelected) {
        this.itemProjectedSelectionState.add(ROOT_KEY);
      }
      setItemProjectedSelection(item, isRootSelected);
    });
    for (const bucket of selectionBucketEntries) {
      let indeterminate = false;
      for (let i = 1; i < bucket.length; i++) {
        if (this.itemToggleState.has(bucket[i]) || this.itemProjectedIndeterminateState.has(bucket[i])) {
          indeterminate = true;
          break;
        }
      }
      if (indeterminate) {
        this.itemProjectedIndeterminateState.add(bucket[0]);
      }
    }
    const computeCounts = (item) => {
      const children = this.treeProps.getChildren(item);
      const selfCount = !this.isGroup(item) && this.isItemSelected(item) ? 1 : 0;
      const count = selfCount + children.reduce((acc, child) => acc + computeCounts(child), 0);
      if (selfCount) {
        this.selectedItems.push(item);
      }
      this.itemKeyToSelectedCount.set(this.getKey(item), count);
      return count;
    };
    for (const item of this.roots) {
      computeCounts(item);
    }
  }
  // Presently, the implementation treats all nodes with children as groups. Groups do not
  // contribute to the counters and are not returned as selected items - only the non-group nodes do.
  // This can be made configurable by exposing the isGroup as property.
  isGroup(item) {
    return this.treeProps.getChildren(item).length > 0;
  }
  getKey(item) {
    return getTrackableValue(this.treeProps.trackBy, item);
  }
  getItemForKey(itemKey) {
    if (itemKey === ROOT_KEY) {
      return null;
    }
    return this.itemKeyToItem.get(itemKey);
  }
  clone() {
    return new _SelectionTree(this.roots, this.treeProps, this.getState());
  }
};

// node_modules/@cloudscape-design/components/internal/environment.js
var PACKAGE_SOURCE = "components";
var PACKAGE_VERSION = "3.0.0 (5cfcc6dc)";
var GIT_SHA = "5cfcc6dc";
var THEME = "open-source-visual-refresh";
var SYSTEM = "core";
var ALWAYS_VISUAL_REFRESH = true;

// node_modules/@cloudscape-design/components/internal/base-component/styles.css.js
import "/Users/hbaisani/Hub Explorations/node_modules/@cloudscape-design/components/internal/base-component/styles.scoped.css";

// node_modules/@cloudscape-design/components/internal/base-component/index.js
initAwsUiVersions(PACKAGE_SOURCE, PACKAGE_VERSION);
function getBaseProps(props) {
  const baseProps = {};
  Object.keys(props).forEach((prop) => {
    if (prop === "id" || prop === "className" || prop.match(/^data-/)) {
      baseProps[prop] = props[prop];
    }
  });
  return baseProps;
}
function getAnalyticsMetadataProps(props) {
  return { ...props === null || props === void 0 ? void 0 : props.analyticsMetadata, ...props === null || props === void 0 ? void 0 : props.__analyticsMetadata };
}

// node_modules/@cloudscape-design/components/internal/hooks/use-visual-mode/index.js
var useVisualRefresh = ALWAYS_VISUAL_REFRESH ? () => true : useRuntimeVisualRefresh;

// node_modules/@cloudscape-design/components/internal/utils/get-visual-theme.js
var getVisualTheme = (theme, isVR) => {
  if (theme === "polaris" && isVR) {
    return "vr";
  }
  return theme;
};

// node_modules/@cloudscape-design/components/internal/hooks/use-base-component/styles-check.js
var import_react13 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/metrics.js
var metrics = new Metrics({ packageSource: PACKAGE_SOURCE, packageVersion: PACKAGE_VERSION, theme: THEME });

// node_modules/@cloudscape-design/components/internal/hooks/use-base-component/styles-check.js
function checkMissingStyles(ownerDocument) {
  if (!ownerDocument.defaultView) {
    return;
  }
  const result = getComputedStyle(ownerDocument.body).getPropertyValue(`--awsui-version-info-${GIT_SHA}`);
  if (!result) {
    console.error(`Missing AWS-UI CSS for theme "${THEME}", version "${PACKAGE_VERSION}", and git sha "${GIT_SHA}".`);
    metrics.sendOpsMetricObject("awsui-missing-css-asset", {});
  }
}
function documentReady(document2, callback) {
  var _a2;
  if (document2.readyState === "complete") {
    callback();
  } else {
    (_a2 = document2.defaultView) === null || _a2 === void 0 ? void 0 : _a2.addEventListener("load", () => callback(), { once: true });
  }
}
async function documentReadyAndIdle(document2, signal) {
  await new Promise((resolve, reject) => {
    signal.addEventListener("abort", () => reject(new DOMException("Aborted", "AbortError")));
    documentReady(document2, () => {
      setTimeout(() => requestIdleCallback(() => resolve()), 1e3);
    });
  });
  const stylesheets = Array.from(document2.querySelectorAll('link[rel="stylesheet"]'));
  await Promise.all(stylesheets.map((link) => {
    if (link.sheet) {
      return Promise.resolve();
    }
    return new Promise((resolve, reject) => {
      function cleanup(done) {
        link.removeEventListener("load", onLoad);
        link.removeEventListener("error", onError);
        signal.removeEventListener("abort", onAbort);
        done();
      }
      const onLoad = () => cleanup(resolve);
      const onError = () => cleanup(resolve);
      const onAbort = () => cleanup(() => reject(new DOMException("Aborted", "AbortError")));
      link.addEventListener("load", onLoad);
      link.addEventListener("error", onError);
      signal.addEventListener("abort", onAbort);
    });
  }));
}
var checkedDocs = /* @__PURE__ */ new WeakMap();
var checkMissingStylesOnce = (document2) => {
  const checked = checkedDocs.get(document2);
  if (!checked) {
    checkMissingStyles(document2);
    checkedDocs.set(document2, true);
  }
};
function useMissingStylesCheck(elementRef) {
  (0, import_react13.useEffect)(() => {
    var _a2, _b;
    if (typeof requestIdleCallback !== "function") {
      return;
    }
    const ownerDocument = (_b = (_a2 = elementRef.current) === null || _a2 === void 0 ? void 0 : _a2.ownerDocument) !== null && _b !== void 0 ? _b : document;
    const abortController = new AbortController();
    documentReadyAndIdle(ownerDocument, abortController.signal).then(() => checkMissingStylesOnce(ownerDocument), (error) => {
      if (error.name !== "AbortError") {
        throw error;
      }
    });
    return () => abortController.abort();
  }, [elementRef]);
}

// node_modules/@cloudscape-design/components/internal/hooks/use-base-component/index.js
function useBaseComponent(componentName, config, analyticsMetadata) {
  const isVisualRefresh = useVisualRefresh();
  const theme = getVisualTheme(THEME, isVisualRefresh);
  useComponentMetrics(componentName, { packageSource: PACKAGE_SOURCE, packageVersion: PACKAGE_VERSION, theme }, config);
  const elementRef = useComponentMetadata(componentName, { packageName: PACKAGE_SOURCE, version: PACKAGE_VERSION, theme }, analyticsMetadata);
  useMissingStylesCheck(elementRef);
  useFocusVisible(elementRef);
  return { __internalRootRef: elementRef };
}

// node_modules/@cloudscape-design/components/internal/utils/apply-display-name.js
function applyDisplayName(component, displayName) {
  component.displayName = displayName;
}

export {
  clsx_m_default,
  useStableCallback,
  useResizeObserver,
  createSingletonHandler,
  createSingletonState,
  findUpUntil,
  nodeContains,
  warnOnce,
  getGlobalFlag,
  useCurrentMode,
  useDensityMode,
  useReducedMotion,
  getIsRtl,
  getOffsetInlineStart,
  getScrollInlineStart,
  getLogicalClientX,
  getLogicalBoundingClientRect,
  getLogicalPageX,
  useSingleTabStopNavigation,
  SingleTabStopNavigationReset,
  SingleTabStopNavigationProvider,
  Portal,
  useMergeRefs,
  useRandomId,
  useUniqueId,
  SelectionTree,
  PACKAGE_VERSION,
  SYSTEM,
  ALWAYS_VISUAL_REFRESH,
  getBaseProps,
  getAnalyticsMetadataProps,
  useVisualRefresh,
  metrics,
  useBaseComponent,
  applyDisplayName
};
//# sourceMappingURL=chunk-WYPZEXZR.js.map
