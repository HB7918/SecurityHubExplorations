// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import { useEffect } from 'react';
import { GIT_SHA, PACKAGE_VERSION, THEME } from '../../environment';
import { metrics } from '../../metrics';
function checkMissingStyles(ownerDocument) {
    if (!ownerDocument.defaultView) {
        // skip the check if this iframe is detached
        return;
    }
    const result = getComputedStyle(ownerDocument.body).getPropertyValue(`--awsui-version-info-${GIT_SHA}`);
    if (!result) {
        console.error(`Missing AWS-UI CSS for theme "${THEME}", version "${PACKAGE_VERSION}", and git sha "${GIT_SHA}".`);
        metrics.sendOpsMetricObject('awsui-missing-css-asset', {});
    }
}
function documentReady(document, callback) {
    var _a;
    if (document.readyState === 'complete') {
        callback();
    }
    else {
        (_a = document.defaultView) === null || _a === void 0 ? void 0 : _a.addEventListener('load', () => callback(), { once: true });
    }
}
async function documentReadyAndIdle(document, signal) {
    await new Promise((resolve, reject) => {
        signal.addEventListener('abort', () => reject(new DOMException('Aborted', 'AbortError')));
        documentReady(document, () => {
            setTimeout(() => requestIdleCallback(() => resolve()), 1000);
        });
    });
    const stylesheets = Array.from(document.querySelectorAll('link[rel="stylesheet"]'));
    await Promise.all(stylesheets.map(link => {
        // already loaded
        if (link.sheet) {
            return Promise.resolve();
        }
        return new Promise((resolve, reject) => {
            function cleanup(done) {
                link.removeEventListener('load', onLoad);
                link.removeEventListener('error', onError);
                signal.removeEventListener('abort', onAbort);
                done();
            }
            const onLoad = () => cleanup(resolve);
            const onError = () => cleanup(resolve);
            const onAbort = () => cleanup(() => reject(new DOMException('Aborted', 'AbortError')));
            link.addEventListener('load', onLoad);
            link.addEventListener('error', onError);
            signal.addEventListener('abort', onAbort);
        });
    }));
}
let checkedDocs = new WeakMap();
const checkMissingStylesOnce = (document) => {
    const checked = checkedDocs.get(document);
    if (!checked) {
        checkMissingStyles(document);
        checkedDocs.set(document, true);
    }
};
export const __testResetCheckedDocs = () => (checkedDocs = new WeakMap());
export function useMissingStylesCheck(elementRef) {
    useEffect(() => {
        var _a, _b;
        // if idle callbacks not supported, we simply do not collect the metric
        if (typeof requestIdleCallback !== 'function') {
            return;
        }
        const ownerDocument = (_b = (_a = elementRef.current) === null || _a === void 0 ? void 0 : _a.ownerDocument) !== null && _b !== void 0 ? _b : document;
        const abortController = new AbortController();
        documentReadyAndIdle(ownerDocument, abortController.signal).then(() => checkMissingStylesOnce(ownerDocument), error => {
            // istanbul ignore next
            if (error.name !== 'AbortError') {
                throw error;
            }
        });
        return () => abortController.abort();
    }, [elementRef]);
}
//# sourceMappingURL=styles-check.js.map